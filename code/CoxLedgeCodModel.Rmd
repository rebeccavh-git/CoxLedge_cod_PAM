---
title: "CoxLedge_cod_model"
author: "Becca Van Hoeck"
date: "10/14/2021"
output: html_document
---
https://github.com/rebeccavh-git/CoxLedge_cod_PAM

Research Questions: 

1. Is the timing of Atlantic cod spawning-associated vocalization, including grunt presence and rate, associated with environmental variables? 
2. Do these environmental associations fall within the variation observed in Massachusetts Bay? 

Data Source:
- Fixed station passive acoustic monitoring data from spawning season of 2013 and 2014 at 1 site on Cox Ledge 
- Data are summarized by cod grunt presence and grunt rate per hour during the spawning season.
- Massachusetts Bay data spans 10 years and spawning associations are previously published

Summary of meeting with James: 11/22

- do not use a full step-wise selection procedure - too many models likely spurious relationships
- Day is likely not best fit by circular variable, center day and switch to parabolic (day + day^2). 
  Find peak in quadratic and define CI of peak 
  ** I fit these terms, but it broke the make_circ function** revisit em_means
- Model selection options:
  1. reasonable background to move forward with global model based on mass bay study (CI will likely be inflated)
  2. Use dredge to make all possible models, then remove nested models with indistinguishable AIC, and average models within 5 AIC
  3. Use biological hypotheses about what we expect to vary between the two regions to establish candidate models
- Estimated marginal means - good approach
  - EM means likely has a confidence interval function
  - revisit to confirm that each variable is held at their mean
  - revisit Micah's code - consider using EMmeans package directly
  - gg_predict likely shows confidence interval
  - otherwise use std errors and link function to generate 95% CI using bootstrapping methods on linear predictors, 
    and back-transform into predictor space


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages

```{r}

library(lunar)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(lme4)
library(lmtest)
library(pscl)
library(MuMIn)
library(emmeans)
library(circular)
library(doBy) # for summaryBy - can I use dplyr/ group_by instead?

```

# Load data
now just modeling cox ledge data and testing whether the peak dates/association falls within the range of mass bay
```{r}
cox = read.csv("data/codCoxModelData.csv", header = TRUE)

```

# Creating sin and cosine variables

```{r}
cox$SpawnSeason = factor(cox$SpawnSeason)

# Hour of the day
cox$shour = sin(2*pi*(cox$hour/24)) 
cox$chour = cos(2*pi*(cox$hour/24)) 

# Julian Day
cox$sday = sin(2*pi*(cox$J/365))
cox$cday = cos(2*pi*(cox$J/365))

cox$daySq = cox$J_center^2

# Lunar cycle  
cox$sLunar = sin(cox$lunarphase) 
cox$cLunar = cos(cox$lunarphase)

#Semi lunar cycle
cox$sLunar2 = sin(cox$lunar2)
cox$cLunar2 = cos(cox$lunar2)


```

# Explore zeros

```{r}
mean(cox$n_grunts) # mean n_grunts = 0.18

cox %>% summarise(sum(n_grunts == 0)/n()) # 96.3% zeros

ggplot(cox, aes(x = n_grunts))+
  geom_bar()

max(cox$n_grunts)

# mean day of grunt presence
codPresence = cox[cox$presence == 1,]
meanDay = mean(codPresence$J)


```

# Mixture model

Questions: 
1. Is this model selection work flow (based on model summary/predictor significance) sufficient?
2. How to choose best model when AIC values are so similar

```{r}
### Global Model

# Zero-inflated Poisson: GLobal Model
Zip1 = zeroinfl(n_grunts ~ SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "poisson", link = "logit", data = cox)
summary(Zip1)

# Zero-inflated negative binomial: Global Model
Zinb1 = zeroinfl(n_grunts ~ SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(Zinb1)

# Zero-inflated negative binomial: Global Model, day as quadratic

Zinbq = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(Zinbq)

# likelihood ratio test between the poisson and neg bin models
# proceed with negative binomial 
lrtest(Zip1, Zinb1) 
AIC(Zip1, Zinb1, Zinbq)

### Candidate models: hypotheses based on Mass Bay results
 
# Global Model
globalMod = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)

# no lunar terms in zero process
Mod1 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour,
                  dist = "negbin", link = "logit", data = cox)

# Only L1 in zero process
Mod2 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar,
                  dist = "negbin", link = "logit", data = cox)

# Only L2 in zero process
Mod3 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)

model.sel(globalMod, Mod1, Mod2, Mod3)
# Mod 3 (only L2 in zero-process) has lowest AIC, delta is 10 to next best

```

# Final model summary & estimated marginal means

Questions: 
1. How to extract predictions from the zero and count processes of the model
2. Estimate marginal means: Do I hold covariates at the mean of observed grunts? 
   (ie. mean hour of the day is 12pm, but mean hour of observed grunts may be 4pm?)
3. Is there a confidence interval around the estimated marginal means?

```{r}

codMod = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(codMod)


## Estimated marginal means
# need to follow the emmeans vignettes to be sure the math behind these params is correct
# confirm mode and whether should use lin.predict = TRUE?
#emm_day_pres = emmeans(codMod, ~ sday + cday, mode = "zero")
#emm_day_rate = emmeans(codMod, ~ sday + cday, mode = "count")

# interpret how they calculated emmeans on circular variables. Set others to their mean and calculated effects?

# Micah's function to calculate circular variables from dataframe input
make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("hour"%in%namez){
      out$shour<-sin(2*pi*(out$hour/24))
      out$chour<-cos(2*pi*(out$hour/24))
    }
    # if("day"%in%namez){
    #   out$sday<-sin(2*pi*(out$day/365))
    #   out$cday<-cos(2*pi*(out$day/365))
    # }
    if("Lunar"%in%namez){
      out$sLunar<-sin(out$Lunar)
      out$cLunar<-cos(out$Lunar)
      out$Lunar2<-out$Lunar
      out$Lunar2[out$Lunar2>pi]<-out$Lunar2[out$Lunar2>pi]-pi
      out$Lunar2<-2*out$Lunar2
      out$sLunar2<-sin(out$Lunar2) #SEMI-LUNAR
      out$cLunar2<-cos(out$Lunar2) #SEMI-LUNAR
    }
    return(out)
  }

## Diel Estimated marginal means following Micah's code 
# Day = 309 (mean day of presence), Full moon
nHour = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=-0.7321493, Lunar=pi, hour=0:23)
nHour = make_circ(nHour)
nHour$presence = predict(codMod, newdata=nHour, type='zero')
nHour$rate = predict(codMod, newdata=nHour, type='count') 
emm_h = summaryBy(cbind(presence,rate)~hour,data=nHour,FUN=mean,keep.names=TRUE)

## Lunar EMM
# why only 1 lunar effect and not two separate for semi-lunar? would predictions be the same, since it's the same cycle?
nLunar = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=-0.7321493, Lunar=seq(0,2*pi,length=16),hour=0)
nLunar = make_circ(nLunar)
nLunar$presence = predict(codMod, newdata=nLunar, type='zero')
nLunar$rate = predict(codMod, newdata=nLunar, type='count')
emm_l<-summaryBy(cbind(presence,rate)~Lunar,data=nLunar,FUN=mean,keep.names=TRUE) 

## Seasonal effect 
# current plot of presence look very weird (why peak in October??)
nDay = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)),day=c(274:365,1:31),Lunar=pi,hour=0)
nDay = make_circ(nDay)
nDay$presence = predict(codMod, newdata=nDay, type='zero')
nDay$rate = predict(codMod, newdata=nDay, type='count')
emm_j<-summaryBy(cbind(presence,rate)~day,data=nDay,FUN=mean,keep.names=TRUE)
#emm_j$edate<-as.Date('2012-12-31')+emm_j$J

emm_j$month = c(rep(1,31),rep(10, 31), rep(11,30), rep(12,31))
emm_j$date = c(1:31,1:31,1:30,1:31)
emm_j$SSorder = emm_j$day
emm_j$SSorder[1:31] = emm_j$SSorder[1:31]+365


```

## Plot EM Means with ggplot

```{r}
# plots in base R

# Diel
ggplot(data=emm_h, aes(x=hour, y = presence))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Presence", limits = c(0,1))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

# ggplot(data=emm_h, aes(x=hour, y = rate))+ theme_bw()+
#   coord_polar(start = 0)+
#   geom_line(size = 1)+
#   scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
#   scale_y_continuous(name = "Grunt Rate", limits = c(0,1))+
#   theme(axis.title = element_text(size = 14),
#         axis.text = element_text(size = 12))

#Lunar
# the rate association is weird
ggplot(data=emm_l, aes(x=Lunar, y = presence))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 2)+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Presence", limits = c(0,1))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_l, aes(x=Lunar, y = rate))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 2)+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Rate", limits = c(0,110))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

# Seasonal
# presence em mean is weird
ggplot(data=emm_j, aes(x=SSorder, y = presence))+ theme_bw()+
  geom_line(size = 1)+
  scale_x_continuous(name = "Month", breaks = c(274,305,335,366), labels = c("Oct", "Nov", "Dec","Jan"))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_j, aes(x=SSorder, y = rate))+ theme_bw()+
  geom_line(size = 1)+
  scale_x_continuous(name = "Month", breaks = c(274,305,335,366), labels = c("Oct", "Nov", "Dec","Jan"))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))


```

## Summarize mass bay variation

Summarize the mean effect of each variable from the Mass Bay model and the confidence around that estimate

```{r}

load("data/gsub.rdat")

# recreate best mass bay model: presence
# BUT THIS WAS A MODEL AVERAGE? HOW TO GET THEIR OUTOUT


```

## Plot comparison of Cox Ledge and Mass Bay

```{r}



```


