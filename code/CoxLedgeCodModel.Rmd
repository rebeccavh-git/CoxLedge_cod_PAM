---
title: "CoxLedge_cod_model"
author: "Becca Van Hoeck"
date: "10/14/2021"
output: html_document
---
https://github.com/rebeccavh-git/CoxLedge_cod_PAM

Research Questions: 

1. Is the timing of Atlantic cod spawning-associated vocalization, including grunt presence and rate, associated with environmental variables? 
2. Do these environmental associations fall within the variation observed in Massachusetts Bay? 

Data Source:
- Fixed station passive acoustic monitoring data from spawning season of 2013 and 2014 at 1 site on Cox Ledge 
- Data are summarized by cod grunt presence and grunt rate per hour during the spawning season.
- Massachusetts Bay data spans 10 years and spawning associations are previously published

Summary of meeting with James: 11/22

- do not use a full step-wise selection procedure - too many models likely spurious relationships
- Day is likely not best fit by circular variable, center day and switch to parabolic (day + day^2). 
  Find peak in quadratic and define CI of peak 
  ** I fit these terms, but it broke the make_circ function** revisit em_means
- Model selection options:
  1. reasonable background to move forward with global model based on mass bay study (CI will likely be inflated)
  2. Use dredge to make all possible models, then remove nested models with indistinguishable AIC, and average models within 5 AIC
  3. Use biological hypotheses about what we expect to vary between the two regions to establish candidate models
- Estimated marginal means - good approach
  - EM means likely has a confidence interval function
  - revisit to confirm that each variable is held at their mean
  - revisit Micah's code - consider using EMmeans package directly
  - ggpredict likely shows confidence interval
  - otherwise use std errors and link function to generate 95% CI using bootstrapping methods on linear predictors, 
    and back-transform into predictor space

vignette exploring residuals: https://aosmith.rbind.io/2017/12/21/using-dharma-for-residual-checks-of-unsupported-models/#example-using-zeroinfl


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages

```{r}

library(lunar)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(lme4)
library(lmtest)
library(pscl)
library(MuMIn)
library(emmeans)
library(circular)
library(doBy) # for summaryBy - can I use dplyr/ group_by instead?

```

# Load data

```{r}
cox = read.csv("data/codCoxModelData.csv", header = TRUE)

```

# Transform predictors to circular or quadratic

```{r}
cox$SpawnSeason = factor(cox$SpawnSeason)

# Hour of the day
cox$shour = sin(2*pi*(cox$hour/24)) 
cox$chour = cos(2*pi*(cox$hour/24)) 

# Julian Day
cox$sday = sin(2*pi*(cox$J/365))
cox$cday = cos(2*pi*(cox$J/365))

cox$daySq = cox$J_center^2

# Lunar cycle  
cox$sLunar = sin(cox$lunarphase) 
cox$cLunar = cos(cox$lunarphase)

#Semi lunar cycle
cox$sLunar2 = sin(cox$lunar2)
cox$cLunar2 = cos(cox$lunar2)


```

# Explore zeros

```{r}
mean(cox$n_grunts) # mean n_grunts = 0.18

cox %>% summarise(sum(n_grunts == 0)/n()) # 96.3% zeros

ggplot(cox, aes(x = n_grunts))+
  geom_bar()

max(cox$n_grunts)

# mean day of grunt presence
codPresence = cox[cox$presence == 1,]
meanDay = mean(codPresence$J)


```

# Mixture model: compare poisson with neg binomial of global mode

```{r}
### Global Model

# Zero-inflated Poisson: GLobal Model
Zip1 = zeroinfl(n_grunts ~ SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "poisson", link = "logit", data = cox)
summary(Zip1)

# Zero-inflated negative binomial: Global Model
Zinb1 = zeroinfl(n_grunts ~ SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(Zinb1)

# Zero-inflated negative binomial: Global Model, day as quadratic

Zinbq = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(Zinbq)

# likelihood ratio test between the poisson and neg bin models
# proceed with negative binomial 
lrtest(Zip1, Zinb1) 
AIC(Zip1, Zinb1, Zinbq)
```

## Moving forward with Negative Binomial - build candidate models

Caiger et al (Mass Bay paper): best models used as candidate models for Cox Ledge data set 
```{r}
### Candidate models: hypotheses based on Mass Bay results
 
# Global Model
globalMod = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox, na.action = na.fail)

# no lunar terms in zero process
Mod1 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour,
                  dist = "negbin", link = "logit", data = cox)

# Only L1 in zero process
Mod2 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar,
                  dist = "negbin", link = "logit", data = cox)

# Only L2 in zero process
Mod3 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)

# Only L2 in count processes, no lunar in zero
Mod4 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour,
                  dist = "negbin", link = "logit", data = cox)

model.sel(globalMod, Mod1, Mod2, Mod3, Mod4)
# Mod 3 (only L2 in zero-process) has lowest AIC, delta is 10 to next best


```

# Final model summary & estimated marginal means

Questions: 
1. How to extract predictions & CI from the zero and count processes of the model with circular variables

```{r}
codMod = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(codMod)

# EM Means without Micah's code

test_grid = ref_grid(codMod)

## Estimated marginal means
## This does not account for the circular nature?
#emm_day_pres = emmeans(codMod, ~ shour + chour, mode = "zero")
#emm_day_rate = emmeans(codMod, ~ shour + chour, mode = "count")

# interpret how they calculated emmeans on circular variables. Set others to their mean and calculated effects?

# Micah's function to calculate circular variables from dataframe input
make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("hour"%in%namez){
      out$shour<-sin(2*pi*(out$hour/24))
      out$chour<-cos(2*pi*(out$hour/24))
    }
    # if("day"%in%namez){  #original code for when model included circular day
    #   out$sday<-sin(2*pi*(out$day/365))
    #   out$cday<-cos(2*pi*(out$day/365))
    # }
    # if("day"%in%namez){  # my attempt to update this function for the circular variable (it didn't work)
    #   out$J_center<-out$J_center
    #   out$daysq<-out$J_center^2
    # }
    if("Lunar"%in%namez){
      out$sLunar<-sin(out$Lunar)
      out$cLunar<-cos(out$Lunar)
      out$Lunar2<-out$Lunar
      out$Lunar2[out$Lunar2>pi]<-out$Lunar2[out$Lunar2>pi]-pi
      out$Lunar2<-2*out$Lunar2
      out$sLunar2<-sin(out$Lunar2) #SEMI-LUNAR
      out$cLunar2<-cos(out$Lunar2) #SEMI-LUNAR
    }
    return(out)
  }

## Diel Estimated marginal means following Micah's code 
# Day = 309 (mean day of presence), Full moon
nHour = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=-0.7321493, daySq=0.5360426, Lunar=pi, hour=0:23)
nHour = make_circ(nHour)
nHour$presence = predict(codMod, newdata=nHour, type='zero')
nHour$rate = predict(codMod, newdata=nHour, type='count') 
emm_h = summaryBy(cbind(presence,rate)~hour,data=nHour,FUN=mean,keep.names=TRUE)

## Lunar EMM
nLunar = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=-0.7321493, daySq=0.5360426,
                    Lunar=seq(0,2*pi,length=16),hour=0)
nLunar = make_circ(nLunar)
nLunar$presence = predict(codMod, newdata=nLunar, type='zero')
nLunar$rate = predict(codMod, newdata=nLunar, type='count')
emm_l<-summaryBy(cbind(presence,rate)~Lunar,data=nLunar,FUN=mean,keep.names=TRUE) 

## Seasonal effect 
J_centerRange = unique(cox$J_center)
daySqRange = unique(cox$daySq)
nDay = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)),J_center=J_centerRange, daySq = daySqRange ,Lunar=pi,hour=0)
nDay = make_circ(nDay)
nDay$presence = predict(codMod, newdata=nDay, type='zero')
nDay$rate = predict(codMod, newdata=nDay, type='count')
emm_j<-summaryBy(cbind(presence,rate)~J_center,data=nDay,FUN=mean,keep.names=TRUE)

# my edits to make this dataframe work with the date range
# emm_j$month = c(rep(1,31),rep(10, 31), rep(11,30), rep(12,31))
# emm_j$date = c(1:31,1:31,1:30,1:31)
# emm_j$SSorder = emm_j$day
# emm_j$SSorder[1:31] = emm_j$SSorder[1:31]+365


```

## Plot EM Means with ggplot

```{r}

# Diel
ggplot(data=emm_h, aes(x=hour, y = presence))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_h, aes(x=hour, y = rate))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

#Lunar
# the rate association is weird
ggplot(data=emm_l, aes(x=Lunar, y = presence))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_l, aes(x=Lunar, y = rate))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

# Seasonal
ggplot(data=emm_j, aes(x=J_center, y = presence))+ theme_bw()+
  geom_line(size = 1)+
  #scale_x_continuous(name = "Month", breaks = c(274,305,335,366), labels = c("Oct", "Nov", "Dec","Jan"))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_j, aes(x=J_center, y = rate))+ theme_bw()+
  geom_line(size = 1)+
  #scale_x_continuous(name = "Month", breaks = c(274,305,335,366), labels = c("Oct", "Nov", "Dec","Jan"))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))


```

## Summarize mass bay variation

Summarize the mean effect of each variable from the Mass Bay model and the confidence around that estimate

```{r}

load("data/gsub.rdat")

# recreate best mass bay model: presence
# BUT THIS WAS A MODEL AVERAGE? HOW TO GET THEIR OUTOUT


```

## Plot comparison of Cox Ledge and Mass Bay

```{r}



```


