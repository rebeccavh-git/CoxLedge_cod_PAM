---
title: "CoxLedge_cod_model"
author: "Becca Van Hoeck"
date: "10/14/2021"
output: html_document
---
https://github.com/rebeccavh-git/CoxLedge_cod_PAM

Research Questions: 

1. Is the timing of Atlantic cod spawning-associated vocalization, including grunt presence and rate, associated with environmental variables? 
2. Do these environmental associations fall within the variation observed in Massachusetts Bay? 

Data Source:
- Fixed station passive acoustic monitoring data from spawning season of 2013 and 2014 at 1 site on Cox Ledge 
- Data are summarized by cod grunt presence and grunt rate per hour during the spawning season.
- Massachusetts Bay data spans 10 years and spawning associations are previously published


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages

```{r}

library(lunar)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
library(lme4)
library(lmtest)
library(pscl)
library(MuMIn)
library(emmeans)
library(circular)
library(doBy) # for summaryBy - can I use dplyr/ group_by instead?

```

# Load data

```{r}
cox = read.csv("data/codCoxModelData.csv", header = TRUE)

```

# Transform predictors to circular or quadratic

```{r}
cox$SpawnSeason = factor(cox$SpawnSeason)

# Hour of the day
cox$shour = sin(2*pi*(cox$hour/24)) 
cox$chour = cos(2*pi*(cox$hour/24)) 

# Julian Day
cox$sday = sin(2*pi*(cox$J/365))
cox$cday = cos(2*pi*(cox$J/365))

cox$daySq = cox$J_center^2

# Lunar cycle  
cox$sLunar = sin(cox$lunarphase) 
cox$cLunar = cos(cox$lunarphase)

#Semi lunar cycle
cox$sLunar2 = sin(cox$lunar2)
cox$cLunar2 = cos(cox$lunar2)


```

# Explore zeros

```{r}
mean(cox$n_grunts) # mean n_grunts = 0.18

cox %>% summarise(sum(n_grunts == 0)/n()) # 96.3% zeros

ggplot(cox, aes(x = n_grunts))+
  geom_bar()

max(cox$n_grunts)

# mean day of grunt presence
codPresence = cox[cox$presence == 1,]
meanDay = mean(codPresence$J)


```

## Build and evaluate Cox Ledge Models

```{r}



```

## Summarize EM Means of best models 

```{r}



```

## Summarize mass bay variation/ find needed code from Micah's script

Code below calculates the EM means from the mass bay model and re-creates their figures from the publication
- once I know how to calculate confidence intervals around these EM means, I can make the comparison
```{r}
load("data/gsub.rdat")
load("data/pam_mixed_modz.rdat")

  #SELECT BEST MODELS FOR PLOTTING 
  bbest<-bmodz$b15
  zbest<-zmodz$z18

## Micah's Functions
  make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("H"%in%namez){
      out$Hsin<-sin(2*pi*(out$H/24))
      out$Hcos<-cos(2*pi*(out$H/24))
    }
    if("J"%in%namez){
      out$Jsin<-sin(2*pi*(out$J/365))
      out$Jcos<-cos(2*pi*(out$J/365))
    }
    if("MOON"%in%namez){
      out$Msin<-sin(out$MOON)
      out$Mcos<-cos(out$MOON)
      out$MOON2<-out$MOON
      out$MOON2[out$MOON2>pi]<-out$MOON2[out$MOON2>pi]-pi
      out$MOON2<-2*out$MOON2
      out$Lsin<-sin(out$MOON2) #SEMI-LUNAR
      out$Lcos<-cos(out$MOON2) #SEMI-LUNAR
    }
    return(out)
  }
 
  
#EST MARGINAL MEANS
#MEAN ACROSS ALL YEARS & SITES, BUT AT MIDNIGHT, FULL MOON, NOV23
if(TRUE){

#DIEL FX
nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=pi,H=0:24,WK=NA,DAY=NA,DEPTH=50)
nd<-make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='link',se.fit = TRUE)))
nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = bbest$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
nd$lwrCIP = bbest$modelInfo$family$linkinv(nd$lwr_link)
nd$uprCIP =  bbest$modelInfo$family$linkinv(nd$upr_link)
# double check that prob below a 0.5, more uncertainty towards 0.5, less uncertainty towards 0
ndRate = as.data.frame(predict(zbest,newdata=nd,type='link',se.fit = TRUE))
ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = zbest$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
ndRate$lwrCIR = zbest$modelInfo$family$linkinv(ndRate$lwr_link)
ndRate$uprCIR =  zbest$modelInfo$family$linkinv(ndRate$upr_link)  
nd = cbind(nd,ndRate)
emm_hMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~H,data=nd,FUN=mean,keep.names=TRUE)

#LUNAR FX
nd = expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=seq(0,2*pi,length=16),H=0,WK=NA,DAY=NA,DEPTH=50)
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='link',se.fit = TRUE)))
nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = bbest$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
nd$lwrCIP = bbest$modelInfo$family$linkinv(nd$lwr_link)
nd$uprCIP =  bbest$modelInfo$family$linkinv(nd$upr_link)
ndRate = as.data.frame(predict(zbest,newdata=nd,type='link',se.fit = TRUE))
ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = zbest$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
ndRate$lwrCIR = zbest$modelInfo$family$linkinv(ndRate$lwr_link)
ndRate$uprCIR =  zbest$modelInfo$family$linkinv(ndRate$upr_link)  
nd = cbind(nd,ndRate)
emm_lMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~MOON,data=nd,FUN=mean,keep.names=TRUE) 

#ANNUAL FX - OVERALL
nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=275:400,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
nd<-make_circ(nd)
nd$pG<-predict(bbest,newdata=nd,type='response')
nd$rG<-predict(zbest,newdata=nd,type='response')
emm_j<-summaryBy(cbind(pG,rG)~J,data=nd,FUN=mean,keep.names=TRUE)
emm_j$edate<-as.Date('2010-12-31')+emm_j$J
less

# my code for annual FX
nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=275:400,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
nd<-make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='link',se.fit = TRUE)))
nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = bbest$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
nd$lwrCIP = bbest$modelInfo$family$linkinv(nd$lwr_link)
nd$uprCIP =  bbest$modelInfo$family$linkinv(nd$upr_link)
ndRate = as.data.frame(predict(zbest,newdata=nd,type='link',se.fit = TRUE))
ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = zbest$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
ndRate$lwrCIR = zbest$modelInfo$family$linkinv(ndRate$lwr_link)
ndRate$uprCIR =  zbest$modelInfo$family$linkinv(ndRate$upr_link)  
nd = cbind(nd,ndRate)
emm_jMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~J,data=nd,FUN=mean,keep.names=TRUE) 
emm_jMB$edate<-as.Date('2010-12-31')+emm_j$J

## Write Model fits to csv files since code takes prediction take so long to run
write.csv(emm_HMB, "data/emm_DielFX.csv", header = TRUE)
write.csv(emm_lMB,"data/emm_LunarFX.csv", header = TRUE)
write.csv(emm_jMB,"data/emm_AnnualFx.csv", header = TRUE)
}
  
```

## Visualize Mass Bay Estimates and Confidence Intervals

```{r}

emm_HMB = read.csv("data/emm_DielFX.csv", header = TRUE)
emm_lMB = read.csv("data/emm_LunarFX.csv", header = TRUE)
emm_jMB = read.csv("data/emm_AnnualFx.csv", header = TRUE)

## Diel
ggplot(data=emm_hMB, aes(x=H, y = fitted))+ theme_bw()+
coord_polar(start = 0)+
geom_line(size = 1)+
geom_ribbon(aes(ymin = lwrCI, ymax = uprCI,alpha = 2))+
scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
scale_y_continuous(name = "Grunt Presence")+
theme(axis.title = element_text(size = 14),
      axis.text = element_text(size = 12))

ggplot(data=emm_hMB, aes(x=H, y = fittedR))+ theme_bw()+
coord_polar(start = 0)+
geom_line(size = 1)+
geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2))+
scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
scale_y_continuous(name = "Grunt Rate")+
theme(axis.title = element_text(size = 14),
      axis.text = element_text(size = 12))

## Lunar
ggplot(data=emm_lMB, aes(x=MOON, y = fittedP))+ theme_bw()+
coord_polar(start = 0)+
geom_line(size = 1)+
geom_ribbon(aes(ymin = lwrCIP, ymax = uprCIP, alpha = 2))+
scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
scale_y_continuous(name = "Grunt Presence", limits = c(0.2,0.28))+
theme(axis.title = element_text(size = 14),
      axis.text = element_text(size = 12))

ggplot(data=emm_l, aes(x=MOON, y = fittedR))+ theme_bw()+
coord_polar(start = 0)+
geom_line(size = 1)+
geom_ribbon(aes(ymin = lwrcIR, ymax = uprCIR, alpha = 2))+
scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
scale_y_continuous(name = "Grunt Rate", limits = c(2,7))+
theme(axis.title = element_text(size = 14),
      axis.text = element_text(size = 12))


## Annual
# this does not match their figs in the pub
plot(emm_j$edate, emm_j$pG)
plot(emm_j$edate, emm_j$rG)

```

## Mass Bay Additional Figures - I don't think I need these

```{r}
#ANNUAL x SITE FX
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=282:365,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  nd$pG<-predict(bbest,newdata=nd,type='response')
  nd$rG<-predict(zbest,newdata=nd,type='response')
  emm_js<-summaryBy(cbind(pG,rG)~J+Site,data=nd,FUN=mean,keep.names=TRUE)
  emm_js$edate<-as.Date('2010-12-31')+emm_js$J
  sitz<-unique(emm_js$Site)
  peakz<-NULL
  for(s in 1:length(sitz)){
    sub<-subset(emm_js,Site==sitz[s])
    pk_pG<-sub$edate[sub$pG==max(sub$pG)]
    pk_rG<-sub$edate[sub$rG==max(sub$rG)]
    df<-data.frame(Site=sitz[s],peak_pG=pk_pG,peak_rg=pk_rG)
    peakz<-rbind(peakz,df)
  }
  
 
#GGPLOT FIGURE of DIEL, LUNAR FX
if(TRUE){
  alf<-0.5
  yfrac<-0.95
  ############

  ###########
  #PRESENCE
  ymn<-min(c(emm_h$pG,emm_l$pG))
  ymx<-max(c(emm_h$pG,emm_l$pG))
  yrange<-ymx-ymn
  ymn<-ymn-(yrange*0.25)
  ymx<-ymx+(yrange*0.25)

  #DIEL PRESENCE
  xmx<-24
  labz_h<-data.frame(H=c(23,5.5,11,16.5),lab=c("Night","","Day",""))
  colz_h<-rep("black",24); colz_h[7:16]<-"white"; colz_h[c(6,17)]<-"darkgray"; 
  pg_circ_h<-ggplot()+
      geom_rect(aes(xmin=0:23,xmax=1:24,ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_h,alf))+
      coord_polar()+geom_line(data=emm_h,aes(x=H,y=pG),lwd=2)+
      ylim(ymn,ymx)+theme_minimal()+
      theme(
        axis.title = element_blank(),
        axis.text.x = element_blank(),
        plot.title = element_text(hjust=0.5,vjust=1)
      ) +
      ggtitle("Grunt Presence")+
      geom_text(data=labz_h, aes(x=H, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  pg_circ_h  
  
  #LUNAR PRESENCE
  seq_l<-seq(0,2*pi,length=32)
  crp_l<-colorRampPalette(c("black","white","black"))
  colz_l<-crp_l(length(seq_l)-1)
  labz_l<-data.frame(MOON=c(0,pi/2,pi,pi*1.5),lab=c("New Moon","","Full Moon",""))
  pg_circ_l<-ggplot()+geom_rect(aes(xmin=seq_l[-length(seq_l)],xmax=seq_l[-1],ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_l,alf))+
    coord_polar()+geom_line(data=emm_l,aes(x=MOON,y=pG),lwd=2)+ylim(ymn,ymx)+
    theme_minimal()+
    theme(
      axis.title = element_blank(),
      axis.text.x = element_blank(),
      plot.title = element_text(hjust=0.5,vjust=1)
    ) +
    xlab("Lunar")+
    geom_text(data=labz_l, aes(x=MOON, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  pg_circ_l
  
  ############
  #RATE
  ymn<-min(c(emm_h$rG,emm_l$rG))
  ymx<-max(c(emm_h$rG,emm_l$rG))
  yrange<-ymx-ymn
  ymn<-ymn-(yrange*0.25)
  ymx<-ymx+(yrange*0.25)
  
  #DIEL RATE
  labz_h<-data.frame(H=c(23,5.5,11,16.5),lab=c("Night","","Day",""))
  colz_h<-rep("black",24); colz_h[7:16]<-"white"; colz_h[c(6,17)]<-"darkgray"; 
  rg_circ_h<-ggplot()+
    geom_rect(aes(xmin=0:23,xmax=1:24,ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_h,alf))+
    coord_polar()+geom_line(data=emm_h,aes(H,rG),lwd=2)+ylim(ymn,ymx)+theme_minimal()+
    theme(
      axis.title.y=element_blank(),
      axis.title.x=element_blank(),
      axis.text.x = element_blank(),
      plot.title = element_text(hjust=0.5,vjust=1)
    ) +
    ggtitle("Grunt Rate")+
    geom_text(data=labz_h, aes(x=H, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  rg_circ_h
  
  #LUNAR RATE
  seq_l<-seq(0,2*pi,length=32)
  crp_l<-colorRampPalette(c("black","white","black"))
  colz_l<-crp_l(length(seq_l)-1)
  labz_l<-data.frame(MOON=c(0,pi/2,pi,pi*1.5),lab=c("New Moon","","Full Moon",""))
  rg_circ_l<-ggplot()+geom_rect(aes(xmin=seq_l[-length(seq_l)],xmax=seq_l[-1],ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_l,alf))+
    coord_polar()+geom_line(data=emm_l,aes(x=MOON,y=rG),lwd=2)+ylim(ymn,ymx)+
    theme_minimal()+
    theme(
      axis.title = element_blank(),
      axis.text.x = element_blank(),
      plot.title = element_text(hjust=0.5,vjust=1)
    ) +
    geom_text(data=labz_l, aes(x=MOON, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  rg_circ_l
  
  grid.arrange(pg_circ_h,rg_circ_h,pg_circ_l,rg_circ_l,nrow=2)
  
  ht<-5 #HEIGHT OF PLOT IN INCHES
  nr<-2; nc<-2; lmat<-matrix(seq_len(nr*nc),nrow=nr,ncol=nc,byrow=TRUE)
  ggsave("diel_lunar_fx.jpg",marrangeGrob(list(pg_circ_h,rg_circ_h,pg_circ_l,rg_circ_l),layout_matrix=lmat,top="",padding=unit(0,"line")),width=ht*1,height=ht,dpi=600)
  
}

  

```

## Plot comparison of Cox Ledge and Mass Bay

I think I only need one ouput - possibly add Cox Ledge fitted to the plots above

```{r}



```

## Original code for Cox Ledge data with pscl mixture model approach... instead use same approach as Mass Bay 

Mixture model: compare poisson with neg binomial of global mode

```{r}
### Global Model

# Zero-inflated Poisson: GLobal Model
Zip1 = zeroinfl(n_grunts ~ SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "poisson", link = "logit", data = cox)
summary(Zip1)

# Zero-inflated negative binomial: Global Model
Zinb1 = zeroinfl(n_grunts ~ SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + sday + cday + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(Zinb1)

# Zero-inflated negative binomial: Global Model, day as quadratic

Zinbq = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(Zinbq)

# likelihood ratio test between the poisson and neg bin models
# proceed with negative binomial 
lrtest(Zip1, Zinb1) 
AIC(Zip1, Zinb1, Zinbq)
```

## Moving forward with Negative Binomial - build candidate models

Caiger et al (Mass Bay paper): best models used as candidate models for Cox Ledge data set 
```{r}
### Candidate models: hypotheses based on Mass Bay results
 
# Global Model
globalMod = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox, na.action = na.fail)

# no lunar terms in zero process
Mod1 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour,
                  dist = "negbin", link = "logit", data = cox)

# Only L1 in zero process
Mod2 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar,
                  dist = "negbin", link = "logit", data = cox)

# Only L2 in zero process
Mod3 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)

# Only L2 in count processes, no lunar in zero
Mod4 = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour,
                  dist = "negbin", link = "logit", data = cox)

model.sel(globalMod, Mod1, Mod2, Mod3, Mod4)
# Mod 3 (only L2 in zero-process) has lowest AIC, delta is 10 to next best


```

# Final model summary & estimated marginal means

Questions: 
1. How to extract predictions & CI from the zero and count processes of the model with circular variables

```{r}
codMod = zeroinfl(n_grunts ~ SpawnSeason + J_center + daySq + shour + chour + sLunar + cLunar + sLunar2 + cLunar2 |
                  SpawnSeason + J_center + daySq + shour + chour + sLunar2 + cLunar2,
                  dist = "negbin", link = "logit", data = cox)
summary(codMod)

# codMod2 = zeroinfl(n_grunts ~ SpawnSeason + poly(J_center,2) + circHour + sLunar + cLunar + sLunar2 + cLunar2 |
#                   SpawnSeason + poly(J_center,2) + circHour + sLunar2 + cLunar2,
#                   dist = "negbin", link = "logit", data = cox)
# summary(codMod2)
# 
# cox$circHour = as.circular(cox$hour, type = "angles", units = "radians")


# prep for obs vs predicted plot
#library(broom)
#coxPred = augment(codMod, cox)

testPred = predict(codMod)

# Exploring options with emmeans functions

test_grid = ref_grid(codMod)

## Estimated marginal means
emm_year_pres = emmeans(codMod, ~ SpawnSeason, mode = "zero")
emm_year_rate = emmeans(codMod, ~ SpawnSeason, mode = "count")

plot(emm_year_pres)
plot(emm_year_rate)

emm_hour_pres = emmeans(codMod, ~shour+chour, mode = "zero")
emm_hour_rate = emmeans(codMod, ~shour+chour, mode = "count")

#emm_lunar_pres = emmeans(codMod, ~sLunar+cLunar, mode = "zero") # lunar not in zero process
emm_lunar_rate = emmeans(codMod, ~sLunar+cLunar, mode = "count")

emm_lunar2_pres = emmeans(codMod, ~ sLunar2+cLunar2, mode = "zero")
emm_lunar2_rate = emmeans(codMod, ~ sLunar2+cLunar2, mode = "count")
# does this show the expected change in rate, given 1 change in lunar2?
# does that make sense for circular?
plot(emm_lunar2_rate)

# Alternative
library(ggeffects)

ggpredict(codMod, ~shour+chour, type = "zero_inflated")
# this produced output with CI, but I don't think its correct (circular variables not accounted for)

```

## Calculating emmeans following Micah's code
- doesn't work for the new quadratic day variables
- this manually makes reference grid and predicts on this grid, how do I get CI?

```{r}
# interpret how they calculated emmeans on circular variables. Set others to their mean and calculated effects?

# Micah's function to calculate circular variables from dataframe input
make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("hour"%in%namez){
      out$shour<-sin(2*pi*(out$hour/24))
      out$chour<-cos(2*pi*(out$hour/24))
    }
    # if("day"%in%namez){  #original code for when model included circular day
    #   out$sday<-sin(2*pi*(out$day/365))
    #   out$cday<-cos(2*pi*(out$day/365))
    # }
    # if("day"%in%namez){  # my attempt to update this function for the circular variable (it didn't work)
    #   out$J_center<-out$J_center
    #   out$daysq<-out$J_center^2
    # }
    if("Lunar"%in%namez){
      out$sLunar<-sin(out$Lunar)
      out$cLunar<-cos(out$Lunar)
      out$Lunar2<-out$Lunar
      out$Lunar2[out$Lunar2>pi]<-out$Lunar2[out$Lunar2>pi]-pi
      out$Lunar2<-2*out$Lunar2
      out$sLunar2<-sin(out$Lunar2) #SEMI-LUNAR
      out$cLunar2<-cos(out$Lunar2) #SEMI-LUNAR
    }
    return(out)
  }

## Diel Estimated marginal means following Micah's code 
# Day = 309 (mean day of presence), Full moon
nHour = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=-0.7321493, daySq=0.5360426, Lunar=pi, hour=0:23)
nHour = make_circ(nHour)
nHour$presence = predict(codMod, newdata=nHour, type='zero', se.fit = )
nHour$rate = predict(codMod, newdata=nHour, type='count') 
emm_h = summaryBy(cbind(presence,rate)~hour,data=nHour,FUN=mean,keep.names=TRUE)


## Lunar EMM
nLunar = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=-0.7321493, daySq=0.5360426,
                    Lunar=seq(0,2*pi,length=16),hour=0)
nLunar = make_circ(nLunar)
nLunar$presence = predict(codMod, newdata=nLunar, type='zero')
nLunar$rate = predict(codMod, newdata=nLunar, type='count')
emm_l<-summaryBy(cbind(presence,rate)~Lunar,data=nLunar,FUN=mean,keep.names=TRUE) 

## Seasonal effect 
J_centerRange = unique(cox$J_center)
daySqRange = unique(cox$daySq)
nDay = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)),J_center=J_centerRange, daySq = daySqRange ,Lunar=pi,hour=0)
nDay = make_circ(nDay)
nDay$presence = predict(codMod, newdata=nDay, type='zero')
nDay$rate = predict(codMod, newdata=nDay, type='count')
emm_j<-summaryBy(cbind(presence,rate)~J_center,data=nDay,FUN=mean,keep.names=TRUE)

# my edits to make this dataframe work with the date range
# emm_j$month = c(rep(1,31),rep(10, 31), rep(11,30), rep(12,31))
# emm_j$date = c(1:31,1:31,1:30,1:31)
# emm_j$SSorder = emm_j$day
# emm_j$SSorder[1:31] = emm_j$SSorder[1:31]+365


```

## Plot EM Means with ggplot

```{r}

# Diel
ggplot(data=emm_h, aes(x=hour, y = presence))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_h, aes(x=hour, y = rate))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

#Lunar
# the rate association is weird
ggplot(data=emm_l, aes(x=Lunar, y = presence))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_l, aes(x=Lunar, y = rate))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

# Seasonal
# these estimates are still weird - makes me less confident in the model
ggplot(data=emm_j, aes(x=J_center, y = presence))+ theme_bw()+
  geom_line(size = 1)+
  #scale_x_continuous(name = "Month", breaks = c(274,305,335,366), labels = c("Oct", "Nov", "Dec","Jan"))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

ggplot(data=emm_j, aes(x=J_center, y = rate))+ theme_bw()+
  geom_line(size = 1)+
  #scale_x_continuous(name = "Month", breaks = c(274,305,335,366), labels = c("Oct", "Nov", "Dec","Jan"))+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))


```



