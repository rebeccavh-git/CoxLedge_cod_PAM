---
title: "CoxLedge_cod_model"
author: "Becca Van Hoeck"
date: "10/14/2021"
output: html_document
---
https://github.com/rebeccavh-git/CoxLedge_cod_PAM

Research Questions: 

1. Is the timing of Atlantic cod spawning-associated vocalization, including grunt presence and rate, associated with environmental variables? 
2. Do these environmental associations fall within the variation observed in Massachusetts Bay? 

Data Source:
- Fixed station passive acoustic monitoring data from spawning season of 2013 and 2014 at 1 site on Cox Ledge 
- Data are summarized by cod grunt presence and grunt rate per hour during the spawning season.
- Massachusetts Bay data spans 10 years and spawning associations are previously published


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages

```{r}

library(lunar)
library(dplyr)
library(tidyr)
library(lubridate)
library(ggplot2)
#library(lme4)
#library(lmtest)
#library(pscl)
library(MuMIn)
library(emmeans)
library(circular)
library(doBy) # for summaryBy - can I use dplyr/ group_by instead?
library(glmmTMB)
library(gridExtra)

```

# Load data

```{r}
cox = read.csv("data/codCoxModelData.csv", header = TRUE)

```

# Transform predictors to circular or quadratic

```{r}
cox$SpawnSeason = factor(cox$SpawnSeason)

# Hour of the day
cox$shour = sin(2*pi*(cox$hour/24)) 
cox$chour = cos(2*pi*(cox$hour/24)) 

# Julian Day
cox$sday = sin(2*pi*(cox$J/365))
cox$cday = cos(2*pi*(cox$J/365))

cox$daySq = cox$J_center^2

# Lunar cycle  
cox$sLunar = sin(cox$lunarphase) 
cox$cLunar = cos(cox$lunarphase)

#Semi lunar cycle
cox$sLunar2 = sin(cox$lunar2)
cox$cLunar2 = cos(cox$lunar2)


```

# Explore zeros

```{r}
mean(cox$n_grunts) # mean n_grunts = 0.18

cox %>% summarise(sum(n_grunts == 0)/n()) # 96.3% zeros

ggplot(cox, aes(x = n_grunts))+
  geom_bar()

max(cox$n_grunts)

# mean day of grunt presence
PresenceOnly = cox[cox$presence >0,]
PresenceOnly$Jedit = PresenceOnly$J
PresenceOnly$Jedit[PresenceOnly$Jedit <=31] = PresenceOnly$Jedit[PresenceOnly$Jedit <=31]+365
meanDay = mean(PresenceOnly$Jedit)


```

## Build and evaluate Cox Ledge Models

```{r}
#### Presence - binomial

global_P = glmmTMB(presence ~ SpawnSeason + sday + cday + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = binomial)

global_P_quadDay = glmmTMB(presence ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = binomial)

# treating day as a quadratic doesn't substantially improve fit, but it does make more mathematical sense
AIC(global_P, global_P_quadDay)

bin1 = glmmTMB(presence ~ SpawnSeason + J_center + daySq + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = binomial)

bin2 = glmmTMB(presence ~ SpawnSeason + J_center + daySq + sLunar + cLunar + shour + chour + (1|wk),
                   data = cox, family = binomial)

bin3 = glmmTMB(presence ~ SpawnSeason + J_center + daySq + shour + chour + (1|wk),
                   data = cox, family = binomial)

#bin4 = glmmTMB(presence ~ SpawnSeason + J_center + daySq + sLunar + cLunar + shour + chour,
#                   data = cox, family = binomial)

# 2nd best model, but includes day as a circular variable. Delta AIC is 2.3 from global
#bin5 = glmmTMB(presence ~ SpawnSeason + sday + cday + sLunar + cLunar + shour + chour + (1|wk),
#                   data = cox, family = binomial)


model.sel(global_P_quadDay, bin1, bin2, bin3)

# global model is only marginally better than model without L2 terms
# Mass Bay bbest is the same as bin2

#### Rate: Zero-inflated negative binomial
#gtmbcon<-glmmTMBControl(optCtrl=list(iter.max=10e3,eval.max=10e3))

# This threw multiple errors/warnings related to infinite or missing values, and na function evaluation
#global_R = glmmTMB(n_grunts ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
#                   data = cox, family = nbinom1(), 
#                   ziformula = ~.)

global_R_nb2 = glmmTMB(n_grunts ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = nbinom2(),
                   ziformula = ~.)

# global_R_cJ = glmmTMB(n_grunts ~ SpawnSeason + sday + cday + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
#                    data = cox, family = nbinom2(),
#                    ziformula = ~.)
  
zinb1 = glmmTMB(n_grunts ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = nbinom2(),
                   ziformula = ~. - sLunar2 -cLunar2)

zinb2 = glmmTMB(n_grunts ~ SpawnSeason + J_center + daySq + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = nbinom2(),
                   ziformula = ~. - sLunar2 -cLunar2)

# confirm that zero-inflation is needed
#nb1 = glmmTMB(n_grunts ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
#                   data = cox, family = nbinom2())

model.sel(global_R_nb2, zinb1, zinb2)
#model.sel(global_R_nb2, zinb1, zinb2, nb1)

# Global model is still the best
```

## Summarize EM Means of best models 

```{r}
# Best Models
bbestCox = glmmTMB(presence ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = binomial)

zbestCox = glmmTMB(n_grunts ~ SpawnSeason + J_center + daySq + sLunar + cLunar + sLunar2 + cLunar2 + shour + chour + (1|wk),
                   data = cox, family = nbinom2(),
                   ziformula = ~.)

# Function to calculate reference grids
make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("hour"%in%namez){
      out$shour<-sin(2*pi*(out$hour/24))
      out$chour<-cos(2*pi*(out$hour/24))
    }
    # if("day"%in%namez){  #original code for when model included circular day
    #   out$sday<-sin(2*pi*(out$day/365))
    #   out$cday<-cos(2*pi*(out$day/365))
    # }
    # if("day"%in%namez){  # my attempt to update this function for the circular variable (it didn't work)
    #   out$J_center<-out$J_center
    #   out$daysq<-out$J_center^2
    # }
    if("Lunar"%in%namez){
      out$sLunar<-sin(out$Lunar)
      out$cLunar<-cos(out$Lunar)
      out$Lunar2<-out$Lunar
      out$Lunar2[out$Lunar2>pi]<-out$Lunar2[out$Lunar2>pi]-pi
      out$Lunar2<-2*out$Lunar2
      out$sLunar2<-sin(out$Lunar2) #SEMI-LUNAR
      out$cLunar2<-cos(out$Lunar2) #SEMI-LUNAR
    }
    return(out)
  }

# Averages: Midnight, Full moon, Day = 337 (mean day of presence)
# Compare predictions with day = 337 

## Diel EMM
nd = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=0.05631918, daySq=0.0031718495, Lunar=pi, hour=0:24, wk = NA)
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbestCox,newdata=nd,type='link',se.fit = TRUE)))
nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = bbestCox$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
nd$lwrCIP = bbestCox$modelInfo$family$linkinv(nd$lwr_link)
nd$uprCIP =  bbestCox$modelInfo$family$linkinv(nd$upr_link)
ndRate = as.data.frame(predict(zbestCox,newdata=nd,type='link',se.fit = TRUE))
ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = zbestCox$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
ndRate$lwrCIR = zbestCox$modelInfo$family$linkinv(ndRate$lwr_link)
ndRate$uprCIR =  zbestCox$modelInfo$family$linkinv(ndRate$upr_link)  
nd = cbind(nd,ndRate)
emm_hCox = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~hour,data=nd,FUN=mean,keep.names=TRUE)

#### Take 2: Diel EMM With type = response for rate
# type=response did not change presence fit, but did change the CI and everything for the rate model
nd = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=0.05631918, daySq=0.0031718495, Lunar=pi, hour=0:24, wk = NA)
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbestCox,newdata=nd,type='response',se.fit = TRUE)))
nd$lwrCIP = nd$fit + qnorm(0.025)*nd$se.fit 
nd$uprCIP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = nd$fit
ndRate = as.data.frame(predict(zbestCox,newdata=nd,type='response',se.fit = TRUE))
ndRate$lwrCIR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$uprCIR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = ndRate$fit
nd = cbind(nd,ndRate[,c(3:5)])
emm_hCox = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~hour,data=nd,FUN=mean,keep.names=TRUE)

## Lunar EMM
nd = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=0.05631918, daySq=0.0031718495,
                    Lunar=seq(0,2*pi,length=16),hour=0, wk = NA)
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbestCox,newdata=nd,type='link',se.fit = TRUE)))
nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = bbestCox$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
nd$lwrCIP = bbestCox$modelInfo$family$linkinv(nd$lwr_link)
nd$uprCIP =  bbestCox$modelInfo$family$linkinv(nd$upr_link)
ndRate = as.data.frame(predict(zbestCox,newdata=nd,type='link',se.fit = TRUE))
ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = zbestCox$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
ndRate$lwrCIR = zbestCox$modelInfo$family$linkinv(ndRate$lwr_link)
ndRate$uprCIR =  zbestCox$modelInfo$family$linkinv(ndRate$upr_link)  
nd = cbind(nd,ndRate)
emm_lCox = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~Lunar,data=nd,FUN=mean,keep.names=TRUE)

### Take 2: Lunar
nd = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)), J_center=0.05631918, daySq=0.0031718495,
                    Lunar=seq(0,2*pi,length=16),hour=0, wk = NA)
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbestCox,newdata=nd,type='response',se.fit = TRUE)))
nd$lwrCIP = nd$fit + qnorm(0.025)*nd$se.fit 
nd$uprCIP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = nd$fit
ndRate = as.data.frame(predict(zbestCox,newdata=nd,type='response',se.fit = TRUE))
ndRate$lwrCIR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$uprCIR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = ndRate$fit
nd = cbind(nd,ndRate[,c(3:5)])
emm_lCox = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~Lunar,data=nd,FUN=mean,keep.names=TRUE)


## Annual effect 
J_centerRange = unique(cox$J_center)
nd = expand.grid(SpawnSeason=as.character(unique(cox$SpawnSeason)),J_center=J_centerRange,Lunar=pi,hour=0,wk = NA)
nd$daySq = nd$J_center^2
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbestCox,newdata=nd,type='link',se.fit = TRUE)))
nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = bbestCox$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
nd$lwrCIP = bbestCox$modelInfo$family$linkinv(nd$lwr_link)
nd$uprCIP =  bbestCox$modelInfo$family$linkinv(nd$upr_link)
ndRate = as.data.frame(predict(zbestCox,newdata=nd,type='link',se.fit = TRUE))
ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = zbestCox$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
ndRate$lwrCIR = zbestCox$modelInfo$family$linkinv(ndRate$lwr_link)
ndRate$uprCIR =  zbestCox$modelInfo$family$linkinv(ndRate$upr_link)  
nd = cbind(nd,ndRate)
emm_jCox = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~J_center,data=nd,FUN=mean,keep.names=TRUE)

## Take 2: Annual effect with EMmeans package - not working perfectly
# convert Mass Bay format to work for quadratic day
subsetJ = seq(1,123,by=3)
J = unique(cox$J)[subsetJ]
J_centerRange = unique(cox$J_center)[subsetJ]
daySq = J_centerRange^2
edate<-as.Date('2010-12-31')+J
df_j<-data.frame(J,J_centerRange,daySq,edate)
df_j$J_daySq = paste(df_j$J_centerRange, df_j$daySq, sep = "_")
emm_j_pg<-as.data.frame(emmeans(bbestCox,~J_center+daySq,at=list(J=J,J_center=J_centerRange,daySq=daySq)),type='response')
emm_j_rg<-as.data.frame(emmeans(zbestCox,~J_center+daySq,at=list(J=J,J_center=J_centerRange,daySq=daySq)),type='response')
emm_j_pg$J_daySq = paste(emm_j_pg$J_center,emm_j_pg$daySq, sep = "_")
emm_j_rg$J_daySq = paste(emm_j_rg$J_center,emm_j_rg$daySq, sep = "_")
emm_j_pg<-left_join(df_j,emm_j_pg, by = "J_daySq")
emm_j_rg<-left_join(df_j,emm_j_rg, by = "J_daySq")

emm_jCox = df_j
emm_jCox$fittedP = emm_j_pg$prob
emm_jCox$lwrCIP = emm_j_pg$lower.CL
emm_jCox$uprCIP = emm_j_pg$upper.CL
emm_jCox$fittedR = emm_j_rg$response
emm_jCox$lwrCIR = emm_j_rg$lower.CL
emm_jCox$uprCIR = emm_j_rg$upper.CL

write.csv(emm_hCox, "data/emm_DielFX_Cox_v2.csv")
write.csv(emm_lCox,"data/emm_LunarFX_Cox_v2.csv")
write.csv(emm_jCox,"data/emm_AnnualFx_Cox_v2.csv")

```

## Summarize mass bay variation

Code below calculates the EM means from the mass bay model and re-creates their figures from the publication
```{r}
load("data/gsub.rdat")
load("data/pam_mixed_modz.rdat")

#SELECT BEST MODELS FOR PLOTTING 
bbest<-bmodz$b15
zbest<-zmodz$z18

## Micah's Functions
make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("H"%in%namez){
      out$Hsin<-sin(2*pi*(out$H/24))
      out$Hcos<-cos(2*pi*(out$H/24))
    }
    if("J"%in%namez){
      out$Jsin<-sin(2*pi*(out$J/365))
      out$Jcos<-cos(2*pi*(out$J/365))
    }
    if("MOON"%in%namez){
      out$Msin<-sin(out$MOON)
      out$Mcos<-cos(out$MOON)
      out$MOON2<-out$MOON
      out$MOON2[out$MOON2>pi]<-out$MOON2[out$MOON2>pi]-pi
      out$MOON2<-2*out$MOON2
      out$Lsin<-sin(out$MOON2) #SEMI-LUNAR
      out$Lcos<-cos(out$MOON2) #SEMI-LUNAR
    }
    return(out)
  }
 
  
#EST MARGINAL MEANS
#MEAN ACROSS ALL YEARS & SITES, BUT AT MIDNIGHT, FULL MOON, NOV23

#DIEL FX
# nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=pi,H=0:24,WK=NA,DAY=NA,DEPTH=50)
# nd<-make_circ(nd)
# nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='link',se.fit = TRUE)))
# nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
# nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
# nd$fittedP = bbest$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
# nd$lwrCIP = bbest$modelInfo$family$linkinv(nd$lwr_link)
# nd$uprCIP =  bbest$modelInfo$family$linkinv(nd$upr_link)
# # double check that prob below a 0.5, more uncertainty towards 0.5, less uncertainty towards 0
# ndRate = as.data.frame(predict(zbest,newdata=nd,type='link',se.fit = TRUE))
# ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
# ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
# ndRate$fittedR = zbest$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
# ndRate$lwrCIR = zbest$modelInfo$family$linkinv(ndRate$lwr_link)
# ndRate$uprCIR =  zbest$modelInfo$family$linkinv(ndRate$upr_link)  
# nd = cbind(nd,ndRate)
# emm_hMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~H,data=nd,FUN=mean,keep.names=TRUE)

# Take 2
nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=pi,H=0:24,WK=NA,DAY=NA,DEPTH=50)
nd<-make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='response',se.fit = TRUE)))
nd$lwrCIP = nd$fit + qnorm(0.025)*nd$se.fit 
nd$uprCIP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = nd$fit
ndRate = as.data.frame(predict(zbest,newdata=nd,type='response',se.fit = TRUE))
ndRate$lwrCIR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
ndRate$uprCIR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = ndRate$fit
nd = cbind(nd,ndRate[,c(3:5)])
emm_lMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~Lunar,data=nd,FUN=mean,keep.names=TRUE)


#LUNAR FX
# nd = expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=seq(0,2*pi,length=16),H=0,WK=NA,DAY=NA,DEPTH=50)
# nd = make_circ(nd)
# nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='link',se.fit = TRUE)))
# nd$lwr_linkP = nd$fit + qnorm(0.025)*nd$se.fit # convert se to CI on link scale
# nd$upr_linkP = nd$fit + qnorm(0.975)*nd$se.fit 
# nd$fittedP = bbest$modelInfo$family$linkinv(nd$fit) # convert fit & CI to probabilities
# nd$lwrCIP = bbest$modelInfo$family$linkinv(nd$lwr_link)
# nd$uprCIP =  bbest$modelInfo$family$linkinv(nd$upr_link)
# ndRate = as.data.frame(predict(zbest,newdata=nd,type='link',se.fit = TRUE))
# ndRate$lwr_linkR = ndRate$fit + qnorm(0.025)*ndRate$se.fit # convert se to CI on link scale
# ndRate$upr_linkR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
# ndRate$fittedR = zbest$modelInfo$family$linkinv(ndRate$fit) # convert fit & CI to probabilities 
# ndRate$lwrCIR = zbest$modelInfo$family$linkinv(ndRate$lwr_link)
# ndRate$uprCIR =  zbest$modelInfo$family$linkinv(ndRate$upr_link)  
# nd = cbind(nd,ndRate)
# emm_lMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~MOON,data=nd,FUN=mean,keep.names=TRUE) 

# take 2
nd = expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=seq(0,2*pi,length=16),H=0,WK=NA,DAY=NA,DEPTH=50)
nd = make_circ(nd)
nd = cbind(nd,as.data.frame(predict(bbest,newdata=nd,type='response',se.fit = TRUE)))
nd$lwrCIP = nd$fit + qnorm(0.025)*nd$se.fit 
nd$uprCIP = nd$fit + qnorm(0.975)*nd$se.fit 
nd$fittedP = nd$fit
ndRate = as.data.frame(predict(zbest,newdata=nd,type='response',se.fit = TRUE))
ndRate$lwrCIR = ndRate$fit + qnorm(0.025)*ndRate$se.fit 
ndRate$uprCIR = ndRate$fit + qnorm(0.975)*ndRate$se.fit 
ndRate$fittedR = ndRate$fit
nd = cbind(nd,ndRate[,c(3:5)])
emm_lMB = summaryBy(cbind(fittedP,lwrCIP,uprCIP,fittedR,lwrCIR,uprCIR)~Lunar,data=nd,FUN=mean,keep.names=TRUE)


## Annual FX overall
# code actually used in Caiger et al for annual fx
emm_options(rg.limit = 200000)

J<-seq(273,365,by=3)
Jsin<-sin(2*pi*(J/365))
Jcos<-cos(2*pi*(J/365))
edate<-as.Date('2010-12-31')+J
df_j<-data.frame(J,Jsin,Jcos,edate)
emm_j_pg<-as.data.frame(emmeans(bbest,~Jsin+Jcos,at=list(J=J,Jsin=Jsin,Jcos=Jcos)),type='response')
emm_j_rg<-as.data.frame(emmeans(zbest,~Jsin+Jcos,at=list(J=J,Jsin=Jsin,Jcos=Jcos)),type='response')
emm_j_pg<-merge(df_j,emm_j_pg)
emm_j_rg<-merge(df_j,emm_j_rg)
# the merge function matches all instances of paired Jsin, Jcos in df_j with the corresponding response/prob and CI from emm_j
# it does not take the max or the average

emm_jMB = df_j
emm_jMB$fittedP = emm_j_pg$prob
emm_jMB$lwrCIP = emm_j_pg$lower.CL
emm_jMB$uprCIP = emm_j_pg$upper.CL
emm_jMB$fittedR = emm_j_rg$response
emm_jMB$lwrCIR = emm_j_rg$lower.CL
emm_jMB$uprCIR = emm_j_rg$upper.CL



## Write Model fits to csv files since code takes prediction take so long to run
write.csv(emm_hMB, "data/emm_DielFX.csv")
write.csv(emm_lMB,"data/emm_LunarFX.csv")
write.csv(emm_jMB,"data/emm_AnnualFx_365.csv")
  
```

## Visualize EM Means and CI comparisons between Mass Bay and Cox Ledge

```{r}
# Cox Ledge
emm_hCox = read.csv("data/emm_DielFX_Cox_v2.csv", header = TRUE)
emm_lCox = read.csv("data/emm_LunarFX_Cox_v2.csv", header = TRUE)
emm_jCox = read.csv("data/emm_AnnualFx_Cox_v2.csv", header = TRUE)
# Mass Bay
emm_hMB = read.csv("data/emm_DielFX.csv", header = TRUE)
emm_lMB = read.csv("data/emm_LunarFX.csv", header = TRUE)
emm_jMB = read.csv("data/emm_AnnualFx_365.csv", header = TRUE)

# Presence 

## Diel
ggplot(data=emm_hMB, aes(x=H, y = fittedP))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  geom_ribbon(aes(ymin = lwrCIP, ymax = uprCIP,alpha = 2))+
  geom_line(data = emm_hCox, aes(x = hour, y = fittedP), size = 1, color = "blue")+
  geom_ribbon(data= emm_hCox, aes(x = hour, ymin = lwrCIP, ymax = uprCIP, alpha = 2))+
  scale_x_continuous(name = "Hour", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

## Lunar
ggplot(data=emm_lMB, aes(x=MOON, y = fittedP))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  geom_ribbon(aes(ymin = lwrCIP, ymax = uprCIP, alpha = 2))+
  geom_line(data = emm_lCox, aes(x = Lunar, y = fittedP), size = 1, color = "blue")+
  geom_ribbon(data= emm_lCox, aes(x = Lunar, ymin = lwrCIP, ymax = uprCIP, alpha = 2))+
  scale_x_continuous(name = "Lunar cycle", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))


## Day Effect
# Edit date variables for plotting
# emm_jMB$Date = ymd(emm_jMB$edate)
# coxDates = ymd_hms(cox$DateTime)
# coxEffort = date(coxDates)
# coxEffort = unique(coxEffort)
# coxEffort = coxEffort[1:123]
# emm_jCox$Date = coxEffort

ggplot()+ theme_bw()+
  geom_line(aes(x = X, y = fittedP), size = 2, data = emm_jMB)+
  geom_ribbon(aes(x = X, ymin = lwrCIP, ymax = uprCIP, alpha = 2), data = emm_jMB, show.legend = FALSE)+
  geom_line(aes(x = X, y = fittedP), size = 2, color = "blue", data = emm_jCox)+
  geom_ribbon(aes(x = X, ymin = lwrCIP, ymax = uprCIP, alpha = 2), data = emm_jCox, show.legend = FALSE)+
  scale_x_continuous(name = "Date", breaks = c(1,32,62,93,124), labels = c("Oct 01", "Nov 01","Dec 01", "Jan 01", "Feb 01"))+
  ylab("Probability of grunt presence")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))


# Rate - separate graphs because of different scale between regions

# Diel 
dielMB = ggplot(data=emm_hMB, aes(x=H, y = fittedR))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2), show.legend = FALSE)+
  scale_x_continuous(name = "", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))
dielCox = ggplot(data = emm_hCox, aes(x = hour, y = fittedR))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1, color = "blue")+
  geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2), show.legend = FALSE)+
  scale_x_continuous(name = "", breaks = c(6,12,18,24), labels = c("6", "12", "18","24"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))


## Lunar
lunarMB = ggplot(data=emm_lMB, aes(x=MOON, y = fittedR))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1)+
  geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2), show.legend = FALSE)+
  scale_x_continuous(name = "", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

lunarCox = ggplot(data=emm_lCox, aes(x=Lunar, y = fittedR))+ theme_bw()+
  coord_polar(start = 0)+
  geom_line(size = 1, color = "blue")+
  geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2),show.legend = FALSE)+
  scale_x_continuous(name = "", breaks = c(0,pi/2, pi, 3*pi/2),labels = c("New", "Waxing","Full","Waning"))+
  scale_y_continuous(name = "Grunt Rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

grid.arrange(dielMB, dielCox, lunarMB, lunarCox, nrow = 2, ncol = 2)


# Day
# the rate fit does not match their figs in the pub - likely because I did not use the model average
DayMB = ggplot(data = emm_jMB, aes(x = X, y = fittedR))+ theme_bw()+
  geom_line(size = 2)+
  #geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2), show.legend = FALSE)+
  scale_x_continuous(name = "", breaks = c(1,32,62,93), labels = c("Oct 01", "Nov 01","Dec 01", "Jan 01"))+
  ylab("Predicted grunt rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

DayCox = ggplot(data = emm_jCox, aes(x = X, y = fittedR))+ theme_bw()+
  geom_line(size = 2, color = "blue")+
  geom_ribbon(aes(ymin = lwrCIR, ymax = uprCIR, alpha = 2), show.legend = FALSE)+
  scale_x_continuous(name = "", breaks = c(1,32,62,93,124), labels = c("Oct 01", "Nov 01","Dec 01", "Jan 01", "Feb 01"))+
  ylab("Predicted grunt rate")+
  theme(axis.title = element_text(size = 14),
        axis.text = element_text(size = 12))

grid.arrange(DayMB,DayCox,nrow = 1, ncol = 2)


# # Attempting figure for observed vs predicted at Cox Ledge each spawning season
# # With only one site, I don't think this figure is actually necessary
# # This predicts over every hour, I wanted just a prediction over each day - which is basically the plot above
# cox$fittedP = predict(bbestCox,newdata=cox,type='link',se.fit = FALSE)
# cox$predP = bbestCox$modelInfo$family$linkinv(cox$fittedP)
# 
# cox$fittedR = predict(zbestCox,newdata=cox,type='link',se.fit = FALSE)
# cox$predR =  zbestCox$modelInfo$family$linkinv(cox$fittedP)
# 
# # if want this figure need this code
# meanGruntHrDay = cod %>%
#   group_by(SpawnSeason, month, day) %>%
#   summarize(meanGrunt = mean(n_grunts))
# 
# meanGruntHrDay["month"][meanGruntHrDay["month"] == "1"] = 13
# meanGruntHrDay$monthday = paste(meanGruntHrDay$month, meanGruntHrDay$day, sep = "_")
# 
# # average grunts per hour on each day, (modeled after Zemeckis et al (2019) Fig 6)
# # add model predictions to these also
# ggplot(data = meanGruntHrDay, aes(x = monthday, y = meanGrunt))+ theme_bw()+
#   geom_col()+
#   scale_x_discrete(breaks = c("11_01","12_01","13_01"), 
#                   labels = c("Nov", "Dec", "Jan"))+
#   ylab("Average number of grunts per hour")+
#   facet_grid(rows = vars(SpawnSeason))+
#   theme(axis.title.x = element_blank())

```

##### Mass Bay model averaging code

## Load libraries

```{r}
library(plotrix)
library(suncalc)
library(lunar)
library(ggplot2)
library(tidyverse)
library(gridExtra)
library(circular)
library(pscl)
library(maptools)
library(rgdal)
library(rgeos)
library(glmmTMB)
library(emmeans)
library(doBy)
library(MASS)
library(plyr)
library(ggspatial)
#library(rasterVis)
library(ggsn)
library(grid)
library(itsadug)
library(car)

```

## Functions needed

```{r}
 
LIC<-function(x,crit="AIC"){
    if(crit=="AIC"){IC<-function(x,...)AIC(x,...)}
    if(crit=="BIC"){IC<-function(x,...)BIC(x,...)}
    out<-NULL
    for(i in 1:length(x)){
      ic<-try(IC(x[[i]]))
      this<-NA
      if(!'try-error'%in%class(ic))this<-ic
      out<-c(out,this)
    }
    return(out)
  }
  
  #CALC EQUIVALENT DF FOR A GAM, GLM, etc
edf<-function(x){
    isbad<-'try-error'%in%class(try(nobs(x),silent=TRUE))
    if(!isbad)return(nobs(x)-df.residual(x))
    if(isbad)return(NA)
  } 

ictab<-function(x){
    modz<-names(x)
    aicz<-LIC(x,crit="AIC")
    bicz<-LIC(x,crit="BIC")
    dfz<-unlist(lapply(x,FUN=edf))
    dfz<-round(unlist(lapply(x,FUN=edf)),3)
    daicz<-round(aicz-min(aicz,na.rm=TRUE),1)
    dbicz<-round(bicz-min(bicz,na.rm=TRUE),1)
    wa<-aicz; wa[is.na(wa)]<-Inf;  # wa<-round(Weights(wa),3) # Weights(wa) was erroring
    wb<-bicz; wb[is.na(wb)]<-Inf;  # wb<-round(Weights(wb),3) # Weights(wb) was erroring
    #de<-round(unlist(lapply(x,FUN=devexp)),1)
    df<-data.frame(mod=modz,wA=wa,wB=wb,dAIC=daicz,dBIC=dbicz,AIC=aicz,BIC=bicz,edf=dfz)
    rownames(df)<-NULL
    return(df)
  }
  
# this is why the 
  predict_multimod<-function(modz,weights=rep(1,length(modz)),newdata=NULL,type='response',se.fit=FALSE){
    out<-NULL
    for(m in modz){
      this<-predict(m,newdata=newdata,type=type,se.fit=se.fit)
      out<-cbind(out,this)
    }
    weights<-weights/sum(weights) #NORMALIZE TO SUM TO 1
    return(rowSums(t(t(out)*weights)))
  }
  
 make_circ<-function(d){
    out<-d
    namez<-names(d)
    if("H"%in%namez){
      out$Hsin<-sin(2*pi*(out$H/24))
      out$Hcos<-cos(2*pi*(out$H/24))
    }
    if("J"%in%namez){
      out$Jsin<-sin(2*pi*(out$J/365))
      out$Jcos<-cos(2*pi*(out$J/365))
    }
    if("MOON"%in%namez){
      out$Msin<-sin(out$MOON)
      out$Mcos<-cos(out$MOON)
      out$MOON2<-out$MOON
      out$MOON2[out$MOON2>pi]<-out$MOON2[out$MOON2>pi]-pi
      out$MOON2<-2*out$MOON2
      out$Lsin<-sin(out$MOON2) #SEMI-LUNAR
      out$Lcos<-cos(out$MOON2) #SEMI-LUNAR
    }
    return(out)
  }

 unfun<-function(form){
      y<-as.character(form)
      x<-y[length(y)]
      x<-gsub("Site","S",x)
      x<-gsub("Hsin","H",x)
      x<-gsub("Hcos","H",x)
      x<-gsub("Msin","L1",x)
      x<-gsub("Mcos","L1",x)
      x<-gsub("Jsin","J",x)
      x<-gsub("Jcos","J",x)
      x<-gsub("Lsin","L2",x)
      x<-gsub("Lcos","L2",x)
      x<-gsub("\\(1 \\| WK\\)","rW",x)
      x<-gsub("\\(1 \\| DAY\\)","rD",x)
      vs<-c("H","L1","J","L2","S:J","Y:J","D:M")
      for(v in vs){
        vv<-paste(v,"+",v)
        x<-gsub(vv,v,x,fixed=TRUE)  
      }
      return(x)
    }

```

## Load data

```{r}
load("data/gsub.rdat")
load("data/pam_mixed_modz.rdat")

```

## Identify top models for model averaging

```{r}
  names(bmodz)<-paste("b",1:length(bmodz),sep="")
  btab<-ictab(bmodz) # only got this to run by commenting out part of the ictab function
  btab$mod<-names(bmodz) 
  btab$form<-unlist(lapply(bmodz,function(x){unfun(x[["modelInfo"]]$allForm$formula)}))
  btab$loglik<-unlist(lapply(bmodz,logLik))
  btab$dup<-duplicated(btab[,-1])
  btab$CAND<-grepl("rW",btab$form)&!is.na(btab$AIC)&!btab$dup #A CANDIDATE MODEL FORM?
  btab$dAIC[btab$CAND]<-btab$AIC[btab$CAND]-min(btab$AIC[btab$CAND],na.rm=TRUE)
  btab$w<-round(exp(-0.5*btab$dAIC)/sum(exp(-0.5*btab$dAIC),na.rm=TRUE),4)
  btab$PRED<-btab$w>0.1&!is.na(btab$w)
  btab<-btab[order(-btab$CAND,btab$AIC),][c("mod","form","loglik","AIC","dAIC","w","edf","PRED")]
  btab
  write.csv(btab,file="data/bmod_aic.csv")
  
  #zmodz<-list(z_0,z_w,z_w1,z_w2,z_w3,z_w_z1,z_w_z2,z_w_z3,z_w_z4,z_w_z5,z_w_z6,z_w_z9,z_w_z10,z_w_z11,z_w_z12,z_w_z13,z_w_z14)
  #names(zmodz)<-lapply(zmodz,FUN=function(x){unfun(formula(x))})
  #zmodz[[length(zmodz)+1]]<-zxx5
  names(zmodz)<-paste("z",1:length(zmodz),sep="")
  ztab<-ictab(zmodz)
  ztab$mod<-names(zmodz)
  ztab$form<-unlist(lapply(zmodz,function(x){unfun(x[["modelInfo"]]$allForm$formula)}))
  ztab$ziform<-unlist(lapply(zmodz,function(x){unfun(x[["modelInfo"]]$allForm$ziformula)}))
  ztab$loglik<-unlist(lapply(zmodz,logLik))
  ztab$dup<-duplicated(ztab[,-1])
  ztab$CAND<-grepl("rW",ztab$form)&!grepl("DEPTH",ztab$form)&!is.na(ztab$AIC)&!ztab$dup
  ztab$dAIC[ztab$CAND]<-ztab$AIC[ztab$CAND]-min(ztab$AIC[ztab$CAND],na.rm=TRUE)
  ztab$w<-round(exp(-0.5*ztab$dAIC)/sum(exp(-0.5*ztab$dAIC),na.rm=TRUE),4)
  ztab$PRED<-ztab$w>0.1&!is.na(ztab$w)
  ztab<-ztab[order(-ztab$CAND,ztab$AIC),][c("mod","form","ziform","loglik","AIC","dAIC","w","edf","PRED")]
  ztab
  write.csv(ztab,file="data/zmod_aic.csv")

bbest_mm<-bmodz[btab$mod[btab$PRED]]
zbest_mm<-zmodz[ztab$mod[ztab$PRED]]
bbest_wts<-btab$w[match(names(bbest_mm),btab$mod)]
zbest_wts<-ztab$w[match(names(zbest_mm),ztab$mod)]

```

## Summarize estimated marginal means

```{r}
  #DIEL FX
  print("Diel FX")
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=pi,H=0:24,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  #nd$pG<-predict(bbest,newdata=nd,type='response')
  #nd$rG<-predict(zbest,newdata=nd,type='response')
  #nd$pG<-predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response')
  #nd<-cbind(nd,
  test = predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response', se.fit = TRUE)
  testLink = predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='link', se.fit = TRUE)
  nd$rG<-predict_multimod(zbest_mm,weights=zbest_wts,newdata=nd,type='response')
  emm_h<-summaryBy(cbind(pG,rG)~H,data=nd,FUN=mean,keep.names=TRUE)
  
  #LUNAR FX
  print("Lunar FX")
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=335,MOON=seq(0,2*pi,length=16),H=0,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  #nd$pG<-predict(bbest,newdata=nd,type='response')
  #nd$rG<-predict(zbest,newdata=nd,type='response')
  nd$pG<-predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response')
  nd$rG<-predict_multimod(zbest_mm,weights=zbest_wts,newdata=nd,type='response')
  emm_l<-summaryBy(cbind(pG,rG)~MOON,data=nd,FUN=mean,keep.names=TRUE) 
  
  #SEASONAL FX - OVERALL
  print("Seasonal FX")
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=275:400,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  #nd$pG<-predict(bbest,newdata=nd,type='response')
  #nd$rG<-predict(zbest,newdata=nd,type='response')
  nd$pG<-predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response')
  nd$rG<-predict_multimod(zbest_mm,weights=zbest_wts,newdata=nd,type='response')
  emm_j<-summaryBy(cbind(pG,rG)~J,data=nd,FUN=mean,keep.names=TRUE)
  emm_j$edate<-as.Date('2010-12-31')+emm_j$J
  
  #SEASONAL x SITE FX
  print("Seasonal X Site FX")
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=282:365,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  #nd$pG<-predict(bbest,newdata=nd,type='response')
  #nd$rG<-predict(zbest,newdata=nd,type='response')
  nd$pG<-predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response')
  nd$rG<-predict_multimod(zbest_mm,weights=zbest_wts,newdata=nd,type='response')
  emm_js<-summaryBy(cbind(pG,rG)~J+Site,data=nd,FUN=mean,keep.names=TRUE)
  emm_js$edate<-as.Date('2010-12-31')+emm_js$J
  sitz<-unique(emm_js$Site)
  peakz<-NULL
  for(s in 1:length(sitz)){
    sub<-subset(emm_js,Site==sitz[s])
    pk_pG<-sub$edate[sub$pG==max(sub$pG)]
    pk_rG<-sub$edate[sub$rG==max(sub$rG)]
    df<-data.frame(Site=sitz[s],peak_pG=pk_pG,peak_rg=pk_rG)
    peakz<-rbind(peakz,df)
  }
  
  #SITE FX
  print("Site FX")
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=282:365,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  #nd$pG<-predict(bbest,newdata=nd,type='response')
  #nd$rG<-predict(zbest,newdata=nd,type='response')
  nd$pG<-predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response')
  nd$rG<-predict_multimod(zbest_mm,weights=zbest_wts,newdata=nd,type='response')
  emm_s<-summaryBy(cbind(pG,rG)~Site,data=nd,FUN=mean,keep.names=TRUE)
  
  #ANNUAL
  print("Annual FX")
  nd<-expand.grid(Y=as.character(unique(gsub$Y)),Site=as.character(unique(gsub$Site)),J=282:365,MOON=pi,H=0,WK=NA,DAY=NA,DEPTH=50)
  nd<-make_circ(nd)
  #nd$pG<-predict(bbest,newdata=nd,type='response')
  #nd$rG<-predict(zbest,newdata=nd,type='response')
  #nd$pG<-predict_multimod(bbest_mm,weights=bbest_wts,newdata=nd,type='response')
  annualSE = predict_multimod(bbest_mm, weights=bbest_wts,newdata=nd,type='link',se.fit = TRUE)
  #nd$rG<-predict_multimod(zbest_mm,weights=zbest_wts,newdata=nd,type='response')
  annualSErate = predict_multimod(zbest_mm, weights=zbest_wts,newdata=nd,type='link',se.fit = TRUE)

   emm_y<-summaryBy(cbind(pG,rG)~Y,data=nd,FUN=mean,keep.names=TRUE)
  #emm_y<-summaryBy(pG~Y,data=nd,FUN=mean,keep.names=TRUE)
  emm_y$Y<-as.numeric(as.character(emm_y$Y))
  emm_y<-emm_y[order(emm_y$Y),]
  plot(pG~Y,data=emm_y,type='l')
  
  #emm_ys<-summaryBy(cbind(pG,rG)~Y+Site,data=nd,FUN=mean,keep.names=TRUE)
  emm_ys<-summaryBy(pG~Y+Site,data=nd,FUN=mean,keep.names=TRUE)
  emm_ys$Y<-as.numeric(as.character(emm_ys$Y))
  emm_ys<-emm_ys[order(emm_ys$Y),]
  
  sitz<-unique(emm_ys$Site)
  emm_ys$SiteY<-paste(emm_ys$Site,emm_ys$Y,sep="_")
  plot(pG~Y,data=emm_ys,col=Site,type='n')
  for(s in 1:length(sitz)){
    ltx<-ceiling(s/8)
    lines(pG~Y,data=emm_ys,subset=Site==sitz[s],col=alpha(s,0.33),lty=ltx)
    esub<-subset(emm_ys,SiteY%in%gsub$SiteY)
    lines(pG~Y,data=esub,subset=Site==sitz[s],col=s,lwd=2,lty=ltx)
  }
  legend("topleft",legend=sitz,col=1:length(sitz),cex=0.85,lty=ceiling((1:length(sitz))/8),lwd=2)
  
}

#GGPLOT FIGURE of DIEL, LUNAR FX
if(TRUE){
  alf<-0.5
  yfrac<-0.95
  ############

  ###########
  #PRESENCE
  ymn<-min(c(emm_h$pG,emm_l$pG))
  ymx<-max(c(emm_h$pG,emm_l$pG))
  yrange<-ymx-ymn
  ymn<-ymn-(yrange*0.25)
  ymx<-ymx+(yrange*0.25)

  #DIEL PRESENCE
  xmx<-24
  labz_h<-data.frame(H=c(23,5.5,11,16.5),lab=c("Night","","Day",""))
  colz_h<-rep("black",24); colz_h[7:16]<-"white"; colz_h[c(6,17)]<-"darkgray"; 
  pg_circ_h<-ggplot()+
      geom_rect(aes(xmin=0:23,xmax=1:24,ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_h,alf))+
      coord_polar()+geom_line(data=emm_h,aes(x=H,y=pG),lwd=2)+
      ylim(ymn,ymx)+theme_minimal()+
      theme(
        axis.title = element_blank(),
        axis.text.x = element_blank(),
        plot.title = element_text(hjust=0.5,vjust=1)
      ) +
      ggtitle("Grunt Presence")+
      geom_text(data=labz_h, aes(x=H, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
    
  
  #LUNAR PRESENCE
  seq_l<-seq(0,2*pi,length=32)
  crp_l<-colorRampPalette(c("black","white","black"))
  colz_l<-crp_l(length(seq_l)-1)
  labz_l<-data.frame(MOON=c(0,pi/2,pi,pi*1.5),lab=c("New Moon","","Full Moon",""))
  pg_circ_l<-ggplot()+geom_rect(aes(xmin=seq_l[-length(seq_l)],xmax=seq_l[-1],ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_l,alf))+
    coord_polar()+geom_line(data=emm_l,aes(x=MOON,y=pG),lwd=2)+ylim(ymn,ymx)+
    theme_minimal()+
    theme(
      axis.title = element_blank(),
      axis.text.x = element_blank(),
      plot.title = element_text(hjust=0.5,vjust=1)
    ) +
    xlab("Lunar")+
    geom_text(data=labz_l, aes(x=MOON, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  
  
  ############
  #RATE
  ymn<-min(c(emm_h$rG,emm_l$rG))
  ymx<-max(c(emm_h$rG,emm_l$rG))
  yrange<-ymx-ymn
  ymn<-ymn-(yrange*0.25)
  ymx<-ymx+(yrange*0.25)
  
  #DIEL RATE
  labz_h<-data.frame(H=c(23,5.5,11,16.5),lab=c("Night","","Day",""))
  colz_h<-rep("black",24); colz_h[7:16]<-"white"; colz_h[c(6,17)]<-"darkgray"; 
  rg_circ_h<-ggplot()+
    geom_rect(aes(xmin=0:23,xmax=1:24,ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_h,alf))+
    coord_polar()+geom_line(data=emm_h,aes(H,rG),lwd=2)+ylim(ymn,ymx)+theme_minimal()+
    theme(
      axis.title.y=element_blank(),
      axis.title.x=element_blank(),
      axis.text.x = element_blank(),
      plot.title = element_text(hjust=0.5,vjust=1)
    ) +
    ggtitle("Grunt Rate")+
    geom_text(data=labz_h, aes(x=H, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  
  #LUNAR RATE
  seq_l<-seq(0,2*pi,length=32)
  crp_l<-colorRampPalette(c("black","white","black"))
  colz_l<-crp_l(length(seq_l)-1)
  labz_l<-data.frame(MOON=c(0,pi/2,pi,pi*1.5),lab=c("New Moon","","Full Moon",""))
  rg_circ_l<-ggplot()+geom_rect(aes(xmin=seq_l[-length(seq_l)],xmax=seq_l[-1],ymin=!!ymn,ymax=!!ymx*yfrac),fill=alpha(colz_l,alf))+
    coord_polar()+geom_line(data=emm_l,aes(x=MOON,y=rG),lwd=2)+ylim(ymn,ymx)+
    theme_minimal()+
    theme(
      axis.title = element_blank(),
      axis.text.x = element_blank(),
      plot.title = element_text(hjust=0.5,vjust=1)
    ) +
    geom_text(data=labz_l, aes(x=MOON, y=!!ymx, label=lab, hjust=0.5), color="black", size=4 ) 
  
  grid.arrange(pg_circ_h,rg_circ_h,pg_circ_l,rg_circ_l,nrow=2)
  
  ht<-5 #HEIGHT OF PLOT IN INCHES
  nr<-2; nc<-2; lmat<-matrix(seq_len(nr*nc),nrow=nr,ncol=nc,byrow=TRUE)
  #ggsave("diel_lunar_fx.jpg",marrangeGrob(list(pg_circ_h,rg_circ_h,pg_circ_l,rg_circ_l),layout_matrix=lmat,top="",padding=unit(0,"line")),width=ht*1,height=ht,dpi=600)
  ggsave("diel_lunar_fx.pdf",marrangeGrob(list(pg_circ_h,rg_circ_h,pg_circ_l,rg_circ_l),layout_matrix=lmat,top="",padding=unit(0,"line")),width=ht*1,height=ht,dpi=600)
  
}

```

